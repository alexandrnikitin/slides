Всем привет. Меня зовут Никитин Александр. И сегодня я расскажу про дженерики.
Немного обо мне: я девелопер в компании Адформ, такой же как и вы.
Этот комикс вообщем-то говорит все о компании, high performance, recommendation engine, data scientists, algorithms, но фактически мы просто продаем и показываем баннеры.
Я это признаю.
Немного технический деталей. туду

Ну и к нашим дженерикам. Изначально, идея была сравнить с Джавой и Си++ чтобы показать какой дотнет классный.
Но решил этого не делать т.к. мы и так знаем, что дотнет самый лучший. Ведь так?
Мы вспомним про то, как объекты лежат в памяти, про то, что такое Method table and EEClass. Посмотрим на то, как Дженерики влияют на них и как работают изнутри.
И на какие оптимизации СЛР идет, чтобы дженерики работали быстро.
Будет дессерт и падение производительности в продакшенею. Если будет время, то обсудим некоторые интересные штуки из кода СЛР.

Да, джава. Когда я разрабатывал под дотнет, я всегда думал, что где-то там интересно, в другом мире, стеке, языке.
Эй, у Скалы есть паттерн матчинг, кричали они. Или вот если внедрим Кафку, то сможем обрабатывать миллионы сообщений, или
Акка стримс - на самом острие, и проблемы обработки потока данных сами исчезнуть. И прочие подобные мысли.
И интерес взял свое и я перешел на ДЖВМ. И вот уже почти год как пишу на скале.
И я заметил, что я начал больше материться, хуже спать, приходить с работы и плакать в подушку.
У меня уже нет тех привычных и удобных вещей и тулов, которые были в дотнете. Ну и дженерики, которых просто нет в ДЖВМ.
У нас в Литве говорят… Что дословно означает: собака и к висилице привыкает. Но не будем о плохом.

Дженерики в дотнете. И они классные. Наверно тут нет ни одного девелопера который бы их не использовал и не любил. Есть такие?
У них полно приемуществ. В документации написано, что они упрощают программирование, даже выделено жирным.
Они уменьшают дублирование кода.
Они умные и поддерживают констрейнты, такие как класс или структура, имплементация класса или интерфейса.
Они могут сохранить наследование через ко и контравариацию.
Они улучшают производительность, нет никаких боксингов и анбоксингов, нет кастингов.
И все это во время компиляции. Ну крутотень же!!
Но за все надо платить и скоро мы посмотрим сколько это стоит.

Для начала вспомним, как объекты хранятся в памяти. Когда мы создаем экземпляр объекта, то в куче появляется вот такая структура.
Где первый элемент - это хедер, который может содержать хешкод или адресс в таблице локов.
Второй элемент - это метод тейбл. Дальше уже сами поля объекта.
Так вот переменная "о" это число, которое указывает на метоб тейбл.

А метод тейбл - это …
Давайте я лучше начну с ЕЕКласса. Это класс, он знает все о типе, который он представляет, он дает доступ к своим знаниям через геттеры и сеттеры.
Это довольно сложный класс, состоит из 2000 строк кода и содержит в себе други классы и структуры, которые тоже не маленькие.
Например EEClassOptionalFields что-то вроде словаря для хранения опциональных данных.
EEClassPackedFields - это оптимизация по памяти. ЕЕКласс хранит очень много числовых данных, такие как количество методов, полей, статических методов, статических полей и т.д.
А значения этих чисел обычно небольшие. Так вот он их оптимизирует и обрезает начальные нули, и упаковывает в массив с доступом по индексу.
ЕЕКласс еще называют колд дата. Так вот вернемся к Метод тейблу.

Метод тейбл - это оптимизация. Сюда вынесено все, что нужно для рантайма.
Это обычный массив чисел-адресов с доступом по индексу. Ее еще называют Хот дата.
Он содержит:...


Чтобы посмотреть на то, как они представлены в рантайме, нам поможет Виндбг, великий и ужасный.
Это мощный тул для отладки любых приложений под виндоус, но у него ужасный интерфейс и юзер экспиринс.
Есть те кто его использовал? туду доклад
Для него есть расширения. СОС от команды СЛР и СОСекс от стороннего разработчика. туду еще?
Сан оф страйк не просто красивое название. Когда сформировали команду СЛР, у нее было неформальное название Lightning.
И они сделали тул для дебага рантайма и назвали его Strike, получилось Lightning Strike.
Это был мощный тул, когда пришло время релиза, они его сильно урезали и назвали Son of Strike. Вот такая история.

Давайте возьмем простой класс. У него один филд и один метод. Если мы создадим его экземпляр и сделаем дамп кучи с нашим типом, то увидим наш объект.
И его метод тейбл. Посмотрим на него. Из интересного тут это его имя. Кое-какая статистика. И его таблица методов.
Дело в том что у виндбг и сос в частности есть проблема, он не показывает некоторую информацию и но и показывает лишнюю.

Посмотрим на ЕЕКлас. Тут мы видим филд.

Немного ссылок.

Теперь давайте посмотрим как дженерики влияют на наши Метод тейблы и ЕЕКлассы.
Возьмем вот такой класс и скомпилируем. Получется вот такая штука. Обратим внимание на название, где число указывает арность типа,
т.е. количество дженерик тайп параметров. И !Т вместо типа.
Это своего рода шаблон, который говорит Джитту что этот тип Дженерик и потом будет скомпилирован по-своему.
О чудо! СЛР знает про дженерики!

Создадим инстанс нашего класса с параметром обжект и посмотрим на его метод тейбл.
Имя у нас с параметром обджект. Но у методов внизу странная сигнатура, появился какой-то магический тип System.__Canon.
Посмотрим на ЕЕКласс. Имя тут уже с типом System.__Canon. И тип филда тоже System.__Canon.

Теперь давайте создадим инстанс стринга и посмотрим на его метод тейбл. Имя тут с параметром стринг.
Но у методов по прежнему странная сигнатура с типом System.__Canon.
А если мы посмотрим по-внимательнее то увидим, что адреса на которые ссылается методы совпадают с предыдущим типом. Так же как и ЕЕКласс.
А теперь давайте создадим инстанс валюе типа.
Имя у нас с параметром Инт. Так же как и сигнатуры методов. ЕЕКласс у нас тоже типизирован интом.

Так как же это все работает?
Валюе типы ничего не шарят и у них свои метод тейблы, ЕЕКлассы, свой джиттед код.
Другими словами для каждого валюе типа в качестве дженерик параметра, СЛР скомпилирует свой кусок кода.
Это приводит к такому понятие как коде блоат. Но это неизбежно, т.к. компилятор должен знать размер и лейаут валью типа во время компиляции.

Референс типы имеют свои метод тейблы. И можно сказать, что метод тейбл уникально описывает тип в СЛР.
Но референс типы шарят код методов и ЕЕКласс между собой.
Другими словами, для всех референс типов СЛР скомпилирует один кусок кода.
Это оптимизация по памяти и позволяет очень сильно уменьшить мемори футпринт.
Это возможно, потому что референс типы имеют один и тот же размер и благодаря таблице виртуальных методов.
System.__Canon - это внутренний тип, основная его задача это сообщить Джиту, что тип будет подставлен позже или определен в рантайме.

Правила такие же для дженериков с несколькими тайп параметрами. Если все типа - референс, то код шариться, иначе нет.

Все довольно просто, когда вы вызываете типизированный дженерик метод. Все проверки могут быть сделаны во время компиляции.
Но все становится намного сложнее, когда вы вызываете дженерик метод, когда тип неизвестен, например из другого дженерик метода или класса.
Нам нужно узнать этот тип и единственная возможность это сделать, это во время рантайма. В СЛР это называется "Runtime handle lookup".
Это самый важный аспект, чтобы сделать общий код дженериков таким же эффективным как и обычный код.
Понятно все?

Так на какие же оптимизации СЛР идет, чтобы сделать дженерики быстрыми?
Класслоадер, он проходится по всей иерархии объектов и их методов, и пытается отределить, подходит нам этот тип или нет. Очевидно, что это самый медленный вариант.
Поэтому СЛР добавляет кэш для каждого типа, где ключ это ваш дженерик тип.
Далее идет кеш для типа, где ключ это ваш дженерик тип + рантайм тип. туду
Ну и самое быстрое что возможно, кто догадается?
Это метод тейбл и слоты в нем. Забегая вперед, скажу, что количество слотов определяется на основе эвристики. Мы ее посмотрим.
Ну и производительность каждого слоя.

Ну и десертик. Самое интересное на мой взгляд.
Я работаю над хайлоад лоулатенси фолттолерант и прочими фэнси-шменси системами.
Я в тот момент работал над реал тайм биддинг системой, которая обрабатывала около 500 тыс хттп реквестов в секунду с задержками до 5 мс.
И после небольших изменений мы столкнулись с падением производительности в одном из наших модулей, который парсил строку-юзерагента и определял бот это или нет.
Там на самом деле сложный алгоритм для поиска тысяч ключевых строк в строке.
Падение было заметно, несколько раз в этом модуле. Хотя там почти ничего не менялось. Я максимально упростил и поспроизвел это.

Мы тут видим дженерик класс. У него дженерик филд. В конструкторе вызывается дженерик метод. В методе ран тоже. И его наследник, абсолютно пустой.
И бенчмарк. Создаем базовый тип, наследник. И наследник в 3.5 раза медленнее.
Может кто догадается в чем дело?
Тут на самом деле две вещи.
Я задал вопрос на Стаковерфло. Набежало куча индусов и начали учить как правильно делать бенчмарки.
Тем временем на РСДН был найден интересный воркэраунт. Просто добавь два пустых метода. Мои первые мысли были ЧТО???? Это что за программирование такое, добавил 2 пустых метода и все залетало.
Потом ответили из МС с тем же советом и добавили, что дело эвристическом алгоритме Джита. Стало полегче.
Потом открыли исходники СЛР. Потом была переписка с одним из лидов СЛР команды. Который все очень подробно объяснил и признал, что это баг в СЛР.
Вот его фикс. Коментарий не трогали, он говорит что добавляется денормализованный ключ, чего на самом деле не делалось. Этот редкий момент...

Мораль.
Если ваш код тормозит, то просто добавьте два пустых метода.
На самом деле дотнет делают такие же програмисты как и мы с вами. Они тоже делают ошибки. И это нормально.
Этот баг есть у всех, кто использует дженерики. Мне просто повезло его обнаружить и подергать СЛР команду, чтобы его исправили.
Just for fun. Не было бы интереса, ничего бы этого не было.
